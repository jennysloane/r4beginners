[
  {
    "path": "lessons/2022-10-18-lesson1-syntax/",
    "title": "1. Basic Syntax",
    "description": "In this lesson we will review the basic syntax of R, including defining several common operators.",
    "author": [],
    "date": "2023-02-20",
    "categories": [],
    "contents": "\r\nIn this lesson we will review some of the basic syntax of R,\r\nincluding the following common operators:\r\n<- assignment operator\r\n> greater than operator\r\n< less than operator\r\n== equality operator\r\n!= inequality operator\r\n& and operator\r\n| or operator\r\nSyntax\r\nSyntax in computer programming is a set of rules that defines the\r\nstructure of a language, similar to how we have rules for grammar and\r\nspelling. If you write a sentence with incorrect spelling or grammar,\r\nthe sentence may not make sense. If you write code without proper\r\nsyntax, the code won’t be able to run and you’ll get an error\r\nmessage.\r\nExample\r\nIn this example, we are trying to print the following famous\r\ncoding statement: “hello world”\r\nIn this first R chunk, we can see how to successfully print\r\n“hello world”\r\nTo run the line of code below (aka R chunk) you can either\r\npush the green arrow pointing to the right or click on the line of code\r\nand push ctrl+enter (windows) or cmd+enter (mac)\r\n\r\n\r\nprint(\"hello world\")\r\n\r\n\r\n[1] \"hello world\"\r\n\r\nIn this second R chunk, we can see what happens if we have even the\r\nslightest mistake in our code. R recognizes “print”, but not “Print”\r\nwith a capital P. This is an important lesson because it demonstrates\r\nthat R (and many programming languages) are sensitive to capitalization.\r\nTherefore, if you run a line of code and get an error, it’s always a\r\ngood idea to double check that you’ve spelled everything correctly.\r\n\r\n\r\nPrint(\"hello world\")\r\n\r\n\r\n\r\nOperators\r\nAssignment Operator\r\nIn R, one of the most common operators is the “assignment operator”\r\nwhich looks like this arrow <-\r\nIn most situations, it would also be acceptable to use the = sign,\r\nbut in R, the arrow is the typical notation\r\nIn this next example, we are assigning x to be 10, y to be 25, and z\r\nto be 100\r\nx, y, and z are stored as values (or variables) in our\r\nEnvironment\r\nBefore you run the R chunk below, click on the Environment\r\npane (usually located in the top right corner of RStudio). Watch what\r\nhappens when you run the code below\r\n\r\n\r\nx <- 10\r\nx\r\n\r\n\r\n[1] 10\r\n\r\ny <- 25\r\ny\r\n\r\n\r\n[1] 25\r\n\r\nz <- 100\r\nz\r\n\r\n\r\n[1] 100\r\n\r\nAs you can see, when you use the assignment operator, it saves the\r\nvalues (x, y, z) in your environment. This means that R will remember\r\nthese values\r\nTo test this out, type “z” into your console and press enter and see\r\nwhat happens! Spoiler: it should return the value 100\r\nGreater or Less than\r\nOperators\r\n> greater than operator\r\n< less than operator\r\nIn this example, we will ask if x is greater than y?\r\nRemember, we have x assigned to 10 and y assigned to 25. So, is 10\r\ngreater than 25? True or False?\r\n\r\n\r\nx > y\r\n\r\n\r\n[1] FALSE\r\n\r\nIs x less than y?\r\n\r\n\r\nx < y \r\n\r\n\r\n[1] TRUE\r\n\r\nEquality Operators\r\n== is the equal-to operator\r\nWe can think of the example below as “is x equal to y?”\r\nNotice, in this scenario R will return TRUE or FALSE and the values\r\nof x and y do not change\r\nBe careful not to confuse == and =\r\n\r\n\r\nx == y \r\n\r\n\r\n[1] FALSE\r\n\r\nx # x is still 10\r\n\r\n\r\n[1] 10\r\n\r\nIf we instead had x = y, R doesn’t return anything, but the value of\r\nx has updated in the environment\r\n\r\n\r\nx = y\r\nx # x is now 25\r\n\r\n\r\n[1] 25\r\n\r\nHere, we’ll just re-assign x to 10\r\n\r\n\r\nx <- 10\r\n\r\n\r\n\r\n!= is the not-equal-to operator (opposite of ==)\r\nWe can think of the example below as: “Is x not equal to y,\r\nTrue or False?”\r\n\r\n\r\nx != y \r\n\r\n\r\n[1] TRUE\r\n\r\nThe And Operator\r\n& is the “and” operator\r\nWe can think of this example in two parts: Is z greater than 50 AND\r\nis z less than 200?\r\nRemember, z is 100. So, is it true that 100 > 50 AND 100 <\r\n200?\r\nIn order for this statement to be true, both pieces must be\r\ntrue\r\n\r\n\r\nz > 50 & z < 200 \r\n\r\n\r\n[1] TRUE\r\n\r\nWhat about if we asked the following: is z > 50 AND is z >\r\n200?\r\n\r\n\r\nz > 50 & z > 200\r\n\r\n\r\n[1] FALSE\r\n\r\nThe Or Operator\r\n| is the “or” operator\r\nWe can again think of this example in two parts: is z greater than\r\n50 OR is z greater than 200?\r\nHowever, this time, in order for the statement (aka expression) to\r\nbe true, only one of the parts needs to be true\r\nSo, let’s test the same line of code we had in the last example but\r\nwith an | operator instead of an & operator\r\n\r\n\r\nz > 50 | z > 200\r\n\r\n\r\n[1] TRUE\r\n\r\nTHE END\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-02-20T10:49:57-06:00",
    "input_file": {}
  },
  {
    "path": "lessons/2022-10-19-lesson2-variable-types/",
    "title": "2. Variable Types",
    "description": "In this lesson we will introduce different types of variables.",
    "author": [],
    "date": "2023-02-19",
    "categories": [],
    "contents": "\r\nIn this lesson we will introduce different types of variables,\r\nincluding character, numeric, integer, logical.\r\nTypes of Variables\r\nCharacter\r\nA character is a type of class that contains a string of\r\ncharacters. For example, a name is a string of characters (or\r\nletters).\r\nIn the example below, I’ve saved my name “Jenny” to a variable\r\nI’ve called “my_char”.\r\n\r\n\r\nmy_char <- \"Jenny\"\r\n\r\n\r\n\r\nTo check what type of variable you have, you can use the\r\nclass() function\r\nAll we have to do is insert our variable (my_char) within the\r\nparentheses of our function\r\nNote, we will review functions in a following lesson, but for now\r\njust run the below line of code and see what gets returned\r\n\r\n\r\nclass(my_char)\r\n\r\n\r\n[1] \"character\"\r\n\r\nAs you can see, R returned the word “character” as we may have\r\nexpected\r\nWe can also use the is.character() function to check\r\nif our variable is a character. This function will return either TRUE or\r\nFALSE\r\n\r\n\r\nis.character(my_char)\r\n\r\n\r\n[1] TRUE\r\n\r\nNumeric\r\nNumeric is a type of class that contains whole numbers\r\nor numbers with decimals\r\nLet’s test out a couple of examples\r\nWe will first assign a number to a new variable (my_num1 or\r\nmy_num2)\r\nAnd then we’ll ask R to print (or return) the value for us\r\n\r\n\r\nmy_num1 <- 22 # my favorite number!\r\nmy_num1 \r\n\r\n\r\n[1] 22\r\n\r\nmy_num2 <- 22.22\r\nmy_num2\r\n\r\n\r\n[1] 22.22\r\n\r\nLet’s check the classes of the variables we’ve just created\r\n\r\n\r\nclass(my_num1)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nclass(my_num2)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nWe can see that both of our variables are numeric\r\nInteger\r\nAn integer is a type of class that contains only\r\nwhole numbers\r\nOf course, this is similar to the numeric class, but without\r\ndecimals. So how does R know if a whole number is numeric or an\r\ninteger?\r\nBy default, R will assign any whole number to the numeric class. We\r\nobserved this above when we saw the class of the number 22 was\r\nnumeric\r\nHowever, as we’ll see below, you can convert a numeric class to an\r\ninteger using the as.integer() function\r\n\r\n\r\nmy_int1 <- as.integer(22)\r\nclass(my_int1)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nBut, what happens if we try to convert a number with a decimal to an\r\ninteger?\r\n\r\n\r\nmy_int2 <- as.integer(22.22)\r\nclass(my_int2)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nThis works! It has successfully converted 22.22 to an integer\r\nHowever, it is important to note that 22.22 was forced to become a\r\nwhole number\r\nSo, if we look at my_int2, it is now the whole number 22 rather than\r\nthe decimal 22.22\r\n\r\n\r\nmy_int2\r\n\r\n\r\n[1] 22\r\n\r\nLogical\r\nLogical is a special type of class that contains only two\r\npossible values: TRUE or FALSE\r\nPlease note that the logical values must be written in all caps with\r\nno quotes\r\n\r\n\r\nlog1 <- TRUE\r\nlog2 <- FALSE\r\n\r\n\r\n\r\nOnce again, we’ll check the classes of the variables we’ve just\r\ncreated\r\n\r\n\r\nclass(log1)\r\n\r\n\r\n[1] \"logical\"\r\n\r\nclass(log2)\r\n\r\n\r\n[1] \"logical\"\r\n\r\nWhat happens if we try the following?\r\n\r\n\r\nlog3 <- \"TRUE\"\r\nclass(log3)\r\n\r\n\r\n[1] \"character\"\r\n\r\nBecause TRUE is in “” here, by default R assigns this to the\r\ncharacter class\r\n\r\n\r\nlog4 <- true\r\n\r\n\r\n\r\nThis example doesn’t even run! R gives us an error here saying\r\n“object ‘true’ not found”\r\nSummary\r\nCharacter: list of character strings\r\nNumeric: whole numbers OR numbers with decimals\r\nInteger: Only whole numbers\r\nLogical: TRUE or FALSE\r\nTHE END\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-02-20T10:50:06-06:00",
    "input_file": {}
  },
  {
    "path": "lessons/2022-10-20-lesson3-data-structure/",
    "title": "3. Data Structure - Part 1",
    "description": "In this lesson we will review different data structures in R, including vectors, matrices, and arrays.",
    "author": [],
    "date": "2023-02-18",
    "categories": [],
    "contents": "\r\nA data structure is a unique way of organizing data so that it can be\r\nstored, processed, and retrieved effectively. In this lesson we will\r\nreview some of the different data structures in R, including the\r\nfollowing:\r\nVectors\r\nMatrices\r\nArrays\r\nIn the Data Structure - Part 2 lesson, we will review:\r\nData frames\r\nTibbles\r\nDepending on what you are using R for, you will probably use a\r\nspecific type of data structure most frequently. For example, in my\r\nresearch, I use data frames and tibbles all the time and rarely use\r\nmatrices or arrays. However, it is still useful to be aware of and\r\nunderstand the different types of data structures.\r\nVectors\r\nIn R, a vector is the simplest type of data structure. It is a\r\nsequence of data elements of the same basic type.\r\nIn the example below, we have three people (who happen to be myself\r\nand my two brothers) - Josh, Jenny, and Brandon. Here, we are creating\r\nthree separate vectors:\r\nnames that contains character strings of our\r\nthree names.\r\nage that contains numeric values representing\r\nour respective ages (at least at the time of writing this, but I will\r\nhappily remain 30 forever).\r\nblue_eyes that contains logical values\r\nrepresenting whether we have blue eyes or not.\r\n\r\n\r\nnames <- c(\"Josh\", \"Jenny\", \"Brandon\")\r\nnames\r\n\r\n\r\n[1] \"Josh\"    \"Jenny\"   \"Brandon\"\r\n\r\nage <- c(31, 30, 27)\r\nage\r\n\r\n\r\n[1] 31 30 27\r\n\r\nblue_eyes <- c(TRUE, FALSE, FALSE)\r\nblue_eyes\r\n\r\n\r\n[1]  TRUE FALSE FALSE\r\n\r\nOnce you run the above R chunk, you can click on the Environment tab\r\nand see how the data is stored. It even shows the data types (num, logi,\r\nchr).\r\nIn this example, it’s important to notice that each vector only\r\ncontains one type of data. We can also see the type of data stored with\r\nthe class() function.\r\nThe lines of code below are not being assigned (or saved) to any\r\nvariables, so the results will be returned in the console, but not saved\r\nto the Environment.\r\n\r\n\r\nclass(names)\r\n\r\n\r\n[1] \"character\"\r\n\r\nclass(age)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nclass(blue_eyes)\r\n\r\n\r\n[1] \"logical\"\r\n\r\nMatrices\r\nA matrix has 2 dimensions of data and contains only one type of data.\r\nMatrices look like a typical table. In my experience, matrices typically\r\ncontain numeric values, but there can also be character matrices.\r\nR has a built-in matrix() function.\r\nIn the example below, we will create a matrix of the numbers 1\r\nthrough 25 and fill it into a 5x5 matrix (5 rows and 5 columns).\r\nWe will save our matrix to a variable called\r\nmy_matrix.\r\n\r\n\r\nmy_matrix <- matrix(data = 1:25, nrow = 5, ncol = 5)\r\nmy_matrix\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nWe can see that the data perfectly fill in our matrix.\r\nBy default, R has filled in our matrix by columns, so we can see\r\nthat 1, 2, 3, 4, 5 are filled in the first column and then it moves on\r\nto the next column.\r\nIf you want to fill in your matrix by rows (instead of columns), you\r\ncan set the byrow argument to equal TRUE like in\r\nthe example below.\r\nPlease note, we will review functions and arguments in more\r\ndetail in a couple of lessons.\r\n\r\n\r\nmatrix(data = 1:25, nrow = 5, ncol = 5, byrow = TRUE)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    2    3    4    5\r\n[2,]    6    7    8    9   10\r\n[3,]   11   12   13   14   15\r\n[4,]   16   17   18   19   20\r\n[5,]   21   22   23   24   25\r\n\r\nHere’s an example of a matrix with character strings, specifically\r\nthe colors of the rainbow.\r\nNote, that the character strings are in quotes and wrapped around a\r\nc() function, which simply combines the elements.\r\n\r\n\r\nrainbow_matrix <- matrix(data = c(\"red\", \"orange\", \"yellow\", \r\n                                  \"green\", \"blue\", \"purple\"), nrow = 2, ncol = 3)\r\nrainbow_matrix\r\n\r\n\r\n     [,1]     [,2]     [,3]    \r\n[1,] \"red\"    \"yellow\" \"blue\"  \r\n[2,] \"orange\" \"green\"  \"purple\"\r\n\r\nYou can access an item within your matrix by using []\r\nwhere the first number represents which column and the second represents\r\nwhich row.\r\n\r\n\r\nmy_matrix[2,4]\r\n\r\n\r\n[1] 17\r\n\r\nrainbow_matrix[1,3]\r\n\r\n\r\n[1] \"blue\"\r\n\r\nNext, we’ll test out what happens if we try to create a matrix that\r\nis smaller than our data:\r\n\r\n\r\nmatrix(data = 1:25, nrow = 4, ncol = 4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    5    9   13\r\n[2,]    2    6   10   14\r\n[3,]    3    7   11   15\r\n[4,]    4    8   12   16\r\n\r\nHere, we can see that R did print our 4x4 matrix, but we are also\r\ngiven a useful warning notifying us that the length of our data (25)\r\ndoes not fit\r\nNext, let’s test out what happens if we try to create a matrix that\r\nis larger than our given data:\r\n\r\n\r\nmatrix(data = 1:25, nrow = 6, ncol = 6)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6]\r\n[1,]    1    7   13   19   25    6\r\n[2,]    2    8   14   20    1    7\r\n[3,]    3    9   15   21    2    8\r\n[4,]    4   10   16   22    3    9\r\n[5,]    5   11   17   23    4   10\r\n[6,]    6   12   18   24    5   11\r\n\r\nAgain, we see that R does return our matrix, but notice what happens\r\nafter it reaches our max value of 25… it starts over! R will recycle the\r\nvalues, so after 25, it will go back to 1.\r\nNote that we also get the same warning as we saw previously because\r\nour data does not fit perfectly.\r\nMatrices are often used for data transformation. So as a final\r\nexample of matrices, let’s see how we can easily transform our\r\nmy_matrix matrix to a new matrix that is multiplied by\r\n2.\r\nThis is as simple as multiplying our original matrix by 2!\r\n\r\n\r\n# original matrix\r\nmy_matrix\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\n# matrix multiplied by 2\r\nmy_matrix*2\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    2   12   22   32   42\r\n[2,]    4   14   24   34   44\r\n[3,]    6   16   26   36   46\r\n[4,]    8   18   28   38   48\r\n[5,]   10   20   30   40   50\r\n\r\nArrays\r\nAn array has 1 or more dimensions of data, but only contains a single\r\ndata type.\r\nR has a built-in array() function.\r\nBelow, we will create a simple vector of a sequence 1 through 18\r\nand.\r\nThen we will call the array function to see what happens.\r\nEven though we are calling an array() we can see\r\nthat this type of an array is simply a vector.\r\nNow we know that a 1-dimensional array is a vector.\r\n\r\n\r\nvector <- 1:25\r\n\r\narray(vector)\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22\r\n[23] 23 24 25\r\n\r\nLet’s delve a bit further!\r\nThe array() function has an argument called “dim”,\r\nwhich is where we can set the dimensions.\r\nHere are a few examples of multi-dimensional arrays:\r\n\r\n\r\narray(vector, dim = c(5,5))\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nThis should look very familiar!\r\nThis example is meant to demonstrate that 2 dimensional arrays are\r\nmatrices.\r\nHowever, arrays can also contain more than 2 dimensions…let’s see\r\nwhat happens if we add another dimension.\r\n\r\n\r\narray(vector, dim = c(5,5,2))\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nThe first number in our dim argument tells us how many rows will be\r\nin our array\r\nThe second number specifies the number of columns\r\nThe third number specifies the number of dimensions\r\nHere’s one final example, but I encourage you to play around with the\r\narray() and test out different numbers and dimensions\r\n\r\n\r\narray(vector, dim = c(2,3,4))\r\n\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\n, , 3\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   13   15   17\r\n[2,]   14   16   18\r\n\r\n, , 4\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   19   21   23\r\n[2,]   20   22   24\r\n\r\nFor more examples check out this\r\nwebsite.\r\nTHE END\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-02-20T10:51:36-06:00",
    "input_file": {}
  },
  {
    "path": "lessons/2023-02-18-lesson4-packages-functions/",
    "title": "4. Packages and Functions",
    "description": "In this lesson we will review the basics of packages (including Tidyverse) and functions.",
    "author": [],
    "date": "2023-02-17",
    "categories": [],
    "contents": "\r\nPackages\r\nA package is a collections of code, data, and documentation all\r\nbundled together in a standardized way that can be easily shared and\r\ninstalled by other R users.\r\nInstalling packages: when you want to use a package\r\nfor the first time, you must install the package with\r\ninstall.packages(\"package_name\") - note the package name\r\nmust be in quotes. You only need to install a package 1 time on your\r\nlocal computer, so I suggest using the console to install packages.\r\nLoading packages/libraries: every time you start a\r\nnew session, you have to tell R what packages you want to load in. You\r\ndo this with the library(package_name) - note the package\r\nname does not need to be in quotes here.\r\nTidyverse\r\nTidyverse is a package, well it’s actually a collection of 8 packages\r\n(ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats)\r\nintroduced by Hadley Wickham to help with data manipulation,\r\nexploration, and visualization.\r\nYou can check out the tidyverse to find out\r\nmore details of each of the individual packages.\r\nWhenever you load tidyverse, you’ll see a message saying it’s\r\nattaching all 8 packages. Therefore, you don’t have to load in any of\r\nthe individual packages because they all get loaded in together. This\r\nmeans as long as you load in tidyverse, you can use\r\nfunctions from any one of the 8 packages.\r\n\r\n\r\n# install.packages(\"tidyverse\") # run in console\r\n\r\nlibrary(tidyverse)\r\n\r\n\r\n\r\nPalmerpenguins\r\nAs another example, let’s have a look at the\r\npalmerpenguins package.\r\nIn the palmerpenguins package, there is a dataset\r\ncalled penguins. Therefore, when you install and load in\r\nthe package, you will automatically have access to this dataset.\r\nHowever, if we try to run penguins before we install or\r\nload in the package, we will get an error message saying:\r\nError: object 'penguins' not found.\r\n\r\n\r\npenguins\r\n\r\n\r\n\r\nBut once we install and load in the palmerpenguins, we\r\ncan see the penguins dataset!\r\n\r\n\r\n# install.packages(\"palmerpenguins\")\r\n\r\nlibrary(palmerpenguins)\r\npenguins\r\n\r\n\r\n# A tibble: 344 × 8\r\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\r\n   <fct>   <fct>              <dbl>         <dbl>             <int>\r\n 1 Adelie  Torgersen           39.1          18.7               181\r\n 2 Adelie  Torgersen           39.5          17.4               186\r\n 3 Adelie  Torgersen           40.3          18                 195\r\n 4 Adelie  Torgersen           NA            NA                  NA\r\n 5 Adelie  Torgersen           36.7          19.3               193\r\n 6 Adelie  Torgersen           39.3          20.6               190\r\n 7 Adelie  Torgersen           38.9          17.8               181\r\n 8 Adelie  Torgersen           39.2          19.6               195\r\n 9 Adelie  Torgersen           34.1          18.1               193\r\n10 Adelie  Torgersen           42            20.2               190\r\n# … with 334 more rows, and 3 more variables: body_mass_g <int>,\r\n#   sex <fct>, year <int>\r\n\r\nErrors\r\ninstalling new package…what do you do when you encounter errors?\r\nIf you are an active R user, I can almost guarantee that sooner or\r\nlater you will run into error messages when trying to install an R\r\npackage. So what do you do when this happens? To see, let’s go through\r\nan example.\r\nLet’s say we discovered there’s an emo package that\r\nlet’s us insert emojis and we want to install the package.\r\nLike any other package, the first thing we do is try to install the\r\npackage in the console with the following code:\r\n\r\n\r\ninstall.packages(\"emo\")\r\n\r\n\r\n\r\nUnfortunately, we get a warning message\r\npackage 'emo' is not available for this version of R. At\r\nfirst, this may be a little misleading because you may think the issue\r\nis that you do not have the right version of R.\r\nBut, really the problem is this package does not exist on\r\nComprehensive R Archive Network (CRAN) and the\r\ninstall.packages() function only works for packages that\r\nare part of CRAN.\r\nOne way to check if the package is part of CRAN is to navigate to\r\nthe Packages tab (by default, this should be located in the bottom right\r\npanel of RStudio) and type in the package you’re interested in\r\ninstalling.\r\nWe can see that emo is not there.\r\nSo, if the package is not part of CRAN, what should you do?\r\nTurn to Google! I typically go to Google and search “install\r\npackage X in R”.\r\nFind the package repository on GitHub. If packages aren’t on\r\nCRAN, you should be able to find the package repository on GitHub and\r\nthen you can install the package via devtools (another\r\npackage).\r\nWhen I search for the emo package on Google, this is\r\nthe first link: Emo GitHub\r\nRepository.\r\nOn the GitHub Repository, scroll down and look for instructions on\r\nhow to install the package.\r\nThe code below is taken directly from the website (note, you do have\r\nto install the devtools package if you haven’t already done so).\r\nAll you have to do is run this code in your console and you’ll be\r\nable to install the emo package!\r\n\r\n\r\n# install.packages(\"devtools\")\r\ndevtools::install_github(\"hadley/emo\")\r\n\r\n\r\n\r\nAs a small aside, note that we don’t have to call the library for\r\ndevtools in the code above because we are explicitly\r\ntelling R that the install_github function is from\r\n(::) the devtools package.\r\nThe code above is identical to running the code in two lines like\r\nthis:\r\n\r\n\r\n# install.packages(\"devtools\")\r\nlibrary(devtools)\r\ninstall_github(\"hadley/emo\")\r\n\r\n\r\n\r\nLet’s test it out our new emo package!\r\nRemember, it’s not enough to install the package. We also have to\r\nload the library.\r\n\r\n\r\nlibrary(emo)\r\nji(\"smile\")\r\n\r\n\r\n😄 \r\n\r\nFinally, I want to share this installing\r\npackages blog that I found super helpful, especially this screenshot\r\nof a flow chart on “Approaching Package Issues Systematically”:\r\n\r\nFunctions\r\nA function is a set of statements (or code) organized to perform a\r\nspecific task. Essentially, a function is like a black box where you\r\nenter inputs and you get an output. R has a lot of built-in\r\nfunctions.\r\nFor example, there’s a mean() function that calculates\r\nthe average of the data you include in the function.\r\nHere we can easily calculate the mean of\r\nmy_values:\r\n\r\n\r\nmy_values = c(10,20,30)\r\n\r\nmean(my_values)\r\n\r\n\r\n[1] 20\r\n\r\nArguments\r\nAn argument is the information passed into any given function. In the\r\nexample above we passed in one argument consisting of “my_values”. The\r\noutput returned the average of 10, 20, and 30.\r\nAs another example of this function, let’s say we wanted to get the\r\naverage bill length of the penguins in the palmerpenguins dataset.\r\nHere, we have to specify the dataset and the column of data\r\nwe want to use in our mean calculation. We can do this by using the\r\n$ operator.\r\nHowever, if we run the code below, we get a strange result:\r\n\r\n\r\nmean(penguins$bill_length_mm)\r\n\r\n\r\n[1] NA\r\n\r\nWhy did we get NA? We cannot calculate a mean score if there are NA\r\nvalues, so we need to remove these values.\r\nFortunately, there is an argument that let’s us do\r\njust that: “na.rm = TRUE” (remove NA = TRUE).\r\n\r\n\r\nmean(penguins$bill_length_mm, na.rm = TRUE)\r\n\r\n\r\n[1] 43.92193\r\n\r\nWe can turn to the Help Documentation to see the different arguments\r\nof a function.\r\nHelp Documentation\r\nIf you are using a function for the first time, you may not know\r\nwhere to start.\r\nOne useful tool is R’s help documentation (the Help tab in the\r\nbottom right panel).\r\nYou can simply search for the function name to learn more about the\r\nfunction. For example, the documentation provides a description, usage,\r\narguments, and often even examples.\r\nAs a shortcut You can also type a ? followed by the function name in\r\nthe console. For example, ?mean which will take you\r\ndirectly to the Help Documentation for the mean function.\r\n\r\nmean() Help\r\nDocumentation\r\nFirst, we immediately see the description: “Generic function for the\r\n(trimmed) arithmetic mean”.\r\nThen, we can see that the usage says: “mean(x, …)”\r\nThis means that we need to provide an argument for x. If we scroll\r\ndown a bit further we can see that x is defined. Basically, this is\r\nsaying that in order to calculate a mean score, you need to put in some\r\ndata (aka x)\r\nThe ... tells us that there are other arguments, but\r\nthey are not required. For example, the “na.rm” is one argument, but it\r\nis not required.\r\n\r\nNext, we see a list of the different possible arguments.\r\nAnd if you scroll all the way down to the bottom, you will see\r\nexamples of how to use the function.\r\nWhy Use functions?\r\nFunctions save us a lot of time! We often rely on functions that\r\nother people have written. So, while we could have taken the time to\r\nwrite our own mean function, there’s no need to because the\r\nfunction already exists. It should hopefully be clear from the last\r\nexample how powerful the mean function can be and how much\r\ntime it can save us.\r\nYou can create your own functions specific to your code and your\r\ntasks. As a general rule, if you find yourself writing the same code\r\nmore than twice, you should consider writing a function. Using functions\r\ncan reduce your chances of making errors. For example, if you need to\r\nupdate your code and you have a function, you only need to update it in\r\none place. However, if you have the same code written 5 times, there’s a\r\npretty high chance that you’ll forget to update your code somewhere,\r\nwhich will result in an error.\r\nAlthough writing your own function is beyond the scope of this\r\nlesson, here are some useful websites if you wish to learn\r\nmore:\r\nR for Data\r\nScience: Functions\r\nHow\r\nto create your own functions in R\r\nTHE END\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-02-20T11:02:46-06:00",
    "input_file": {}
  },
  {
    "path": "lessons/2023-02-19-lesson5-data-structure2/",
    "title": "5. Data Structure - Part 2",
    "description": "In this lesson we will review different data structures in R, including data frames and tibbles.",
    "author": [],
    "date": "2023-02-16",
    "categories": [],
    "contents": "\r\nA data structure is a unique way of organizing data so that it can be\r\nstored, processed, and retrieved effectively. In the previous Data\r\nStructure lesson we reviewed vectors, matrices, and arrays. And now in\r\nthis lesson we will review:\r\nData frames\r\nTibbles\r\nData frames\r\nWhat is a data frame? - A data frame is a common way of storing data\r\nin R. Data frames can have variables are different types (e.g. one\r\nvariable may be a character and one may be numeric).\r\nI find the best way to understand a new concept (especially with\r\ncoding) is to work through a concrete example. So here, we will explore\r\nthe penguins dataset that is included in the palmerpenguins package, so\r\nonce you load the library you can take a look at penguins -\r\nhow can we interpret this data? - each row is a unique penguin - each\r\ncolumn is a variable that provides information about the penguin - we\r\ncan see this is a data frame and it actually tells us penguins is\r\nspecifically a “tibble” - tibbles are simple data frames with some\r\nfeatures that make working with the data really nice - shows us exactly\r\nhow big our dataset is (344 rows and 8 columns) - automatically only\r\nprints out the first 10 rows, so we can always see the variable names at\r\nthe top - under each variable name, we see what type of variable it is\r\n(i.e. fct, dbl, int)\r\n\r\n\r\npenguins\r\n\r\nis.data.frame(penguins)\r\nis_tibble(penguins)\r\n\r\nis.data.frame(names)\r\n\r\n\r\n\r\nTibbles\r\nCreate our own tibble\r\nlet’s combine the vectors we created in the previous workshop into a\r\ntibble using tibble()\r\n\r\n\r\nnames <- c(\"xxx\", \"yyy\", \"zzz\")\r\nage <- c(20, 18, 33)\r\nblue_eyes <- c(TRUE, FALSE, FALSE)\r\n\r\nmy_tibble <- tibble(\r\n  Name = names,\r\n  Age = age,\r\n  Blue_eye = blue_eyes\r\n)\r\n\r\nis.data.frame(my_tibble)\r\nis_tibble(my_tibble)\r\n\r\nmy_tibble$Name[1]\r\n\r\nmy_tibble[1,3]\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-02-20T11:03:01-06:00",
    "input_file": {}
  }
]
