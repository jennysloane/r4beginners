[
  {
    "path": "lessons/lesson1-syntax/",
    "title": "1. Basic Syntax",
    "description": "In this lesson we will review the basic syntax in R, including defining several common operators.",
    "author": [],
    "date": "2023-02-20",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nSyntax\r\nExample\r\n\r\nOperators\r\nAssignment Operator\r\nGreater or Less than Operators\r\nEquality Operators\r\nThe And Operator\r\nThe Or Operator\r\n\r\nSummary\r\nTHE END 🎉\r\n\r\nIn this lesson we will review some of the basic syntax in R, including the following common operators:\r\n<- assignment operator\r\n> greater than operator\r\n< less than operator\r\n== equality operator\r\n!= inequality operator\r\n& and operator\r\n| or operator\r\nSyntax\r\nSyntax in computer programming is a set of rules that defines the structure of a language, similar to how we have rules for grammar and spelling. If you write a sentence with incorrect spelling or grammar, the sentence may not make sense. If you write code without proper syntax, the code won’t be able to run and you’ll get an error message.\r\nExample\r\nIn this example, we are trying to print the following famous coding statement: “hello world”.\r\nIn this first R chunk, we can see how to successfully print “hello world”.\r\nTo run the line of code below (aka R chunk) you can either push the green arrow pointing to the right or click on the line of code and push ctrl+enter (windows) or cmd+enter (mac).\r\n\r\n\r\nprint(\"hello world\")\r\n\r\n[1] \"hello world\"\r\n\r\nIn this second R chunk, we can see what happens if we have even the slightest mistake in our code. R recognizes “print”, but not “Print” with a capital P. This is an important lesson because it demonstrates that R (and many programming languages) are sensitive to capitalization. Therefore, if you run a line of code and get an error, it’s always a good idea to double check that you’ve spelled everything correctly.\r\n\r\n\r\nPrint(\"hello world\")\r\n\r\nError in Print(\"hello world\"): could not find function \"Print\"\r\n\r\nOperators\r\nAssignment Operator\r\nIn R, one of the most common operators is the “assignment operator” which looks like this arrow <-.\r\nIn most situations, it would also be acceptable to use the = sign, but in R, the arrow is the typical notation.\r\nIn this next example, we are assigning x to be 10, y to be 25, and z to be 100.\r\nx, y, and z are stored as values (or variables) in our Environment.\r\nBefore you run the R chunk below, click on the Environment pane (usually located in the top right corner of RStudio). Watch what happens when you run the code below. If you’re unfamiliar with the Environment tab, I recommend watching my tutorial on Introduction to R.\r\n\r\n\r\nx <- 10\r\nx\r\n\r\n[1] 10\r\n\r\ny <- 25\r\ny\r\n\r\n[1] 25\r\n\r\nz <- 100\r\nz\r\n\r\n[1] 100\r\n\r\nAs you can see, when you use the assignment operator, it saves the values (x, y, z) in your Environment. This means that R will remember these values.\r\nTo test this out, type “z” into your console and press enter and see what happens! Spoiler: it should return the value 100.\r\nGreater or Less than Operators\r\n> is the greater than operator.\r\n< is the less than operator.\r\nIn this example, we will ask if x is greater than y?\r\nRemember, we have x assigned to 10 and y assigned to 25. So, is 10 greater than 25? True or False?\r\n\r\n\r\nx > y\r\n\r\n[1] FALSE\r\n\r\nIs x less than y?\r\n\r\n\r\nx < y \r\n\r\n[1] TRUE\r\n\r\nEquality Operators\r\n== is the equal-to operator.\r\nWe can think of the example below as “is x equal to y?”.\r\nNotice, in this scenario R will return TRUE or FALSE and the values of x and y do not change.\r\n\r\n\r\nx == y \r\n\r\n[1] FALSE\r\n\r\nx # x is still 10\r\n\r\n[1] 10\r\n\r\nNote here, we have a # followed by some text. A # in R indicates a comment. Any text that follows a # will not be evaluated. This is a great way to leave notes or comments for yourself.\r\nBe careful not to confuse == and =.\r\nIf we instead had x = y, R doesn’t return anything, but the value of x has updated.\r\n\r\n\r\nx = y # remember, this could also be x <- y\r\nx # x is now 25\r\n\r\n[1] 25\r\n\r\nHere, we’ll just re-assign x to 10.\r\n\r\n\r\nx <- 10\r\n\r\n\r\n!= is the not-equal-to operator (opposite of ==).\r\nWe can think of the example below as: “Is x not equal to y, True or False?”.\r\n\r\n\r\nx != y \r\n\r\n[1] TRUE\r\n\r\nThe And Operator\r\n& is the “and” operator.\r\nWe can think of this example in two parts: “Is z greater than 50?” AND “is z less than 200?”.\r\nRemember, z is 100. So, is it true that 100 > 50 AND 100 < 200?\r\nIn order for this statement to be true, both pieces must be true.\r\n\r\n\r\nz > 50 & z < 200 \r\n\r\n[1] TRUE\r\n\r\nWhat about if we asked the following: is z > 50 AND is z > 200?\r\n\r\n\r\nz > 50 & z > 200\r\n\r\n[1] FALSE\r\n\r\nThe Or Operator\r\n| is the “or” operator.\r\nWe can again think of this example in two parts: “is z greater than 50?” OR “is z greater than 200?”.\r\nHowever, this time, in order for the statement (aka expression) to be true, only one of the parts needs to be true.\r\nSo, let’s test the same line of code we had in the last example but with an | operator instead of an & operator.\r\n\r\n\r\nz > 50 | z > 200\r\n\r\n[1] TRUE\r\n\r\nSummary\r\nIn this lesson we learned about syntax in R and some of the most common operators (<-, >, <, ==, !=, !=, &, |).\r\nWe also learned a few useful tips, including how to run R chunks and how to leave comments using the #.\r\nTHE END 🎉\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-03-12T14:22:06-05:00",
    "input_file": {}
  },
  {
    "path": "lessons/lesson2-variable-types/",
    "title": "2. Variable Types",
    "description": "In this lesson we will introduce different types of variables.",
    "author": [],
    "date": "2023-02-19",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nTypes of Variables\r\nCharacter\r\nNumeric\r\nInteger\r\nLogical\r\n\r\nSummary\r\nTHE END 🎉\r\n\r\nIn this lesson we will introduce different types of variables, including character, numeric, integer, logical.\r\nTypes of Variables\r\nCharacter\r\nA character is a type of class that contains a string of characters. For example, a name is a string of characters (or letters).\r\nIn the example below, I’ve saved my name “Jenny” to a variable I’ve called “my_char”.\r\n\r\n\r\nmy_char <- \"Jenny\"\r\n\r\n\r\nTo check what type of variable you have, you can use the class() function\r\nAll we have to do is insert our variable (my_char) within the parentheses of our function\r\nNote, we will review functions in a following lesson, but for now just run the below line of code and see what gets returned\r\n\r\n\r\nclass(my_char)\r\n\r\n[1] \"character\"\r\n\r\nAs you can see, R returned the word “character” as we may have expected\r\nWe can also use the is.character() function to check if our variable is a character. This function will return either TRUE or FALSE\r\n\r\n\r\nis.character(my_char)\r\n\r\n[1] TRUE\r\n\r\nNumeric\r\nNumeric is a type of class that contains whole numbers or numbers with decimals\r\nLet’s test out a couple of examples\r\nWe will first assign a number to a new variable (my_num1 or my_num2)\r\nAnd then we’ll ask R to print (or return) the value for us\r\n\r\n\r\nmy_num1 <- 22 # my favorite number!\r\nmy_num1 \r\n\r\n[1] 22\r\n\r\nmy_num2 <- 22.22\r\nmy_num2\r\n\r\n[1] 22.22\r\n\r\nLet’s check the classes of the variables we’ve just created\r\n\r\n\r\nclass(my_num1)\r\n\r\n[1] \"numeric\"\r\n\r\nclass(my_num2)\r\n\r\n[1] \"numeric\"\r\n\r\nWe can see that both of our variables are numeric\r\nInteger\r\nAn integer is a type of class that contains only whole numbers\r\nOf course, this is similar to the numeric class, but without decimals. So how does R know if a whole number is numeric or an integer?\r\nBy default, R will assign any whole number to the numeric class. We observed this above when we saw the class of the number 22 was numeric\r\nHowever, as we’ll see below, you can convert a numeric class to an integer using the as.integer() function\r\n\r\n\r\nmy_int1 <- as.integer(22)\r\nclass(my_int1)\r\n\r\n[1] \"integer\"\r\n\r\nBut, what happens if we try to convert a number with a decimal to an integer?\r\n\r\n\r\nmy_int2 <- as.integer(22.22)\r\nclass(my_int2)\r\n\r\n[1] \"integer\"\r\n\r\nThis works! It has successfully converted 22.22 to an integer\r\nHowever, it is important to note that 22.22 was forced to become a whole number\r\nSo, if we look at my_int2, it is now the whole number 22 rather than the decimal 22.22\r\n\r\n\r\nmy_int2\r\n\r\n[1] 22\r\n\r\nLogical\r\nLogical is a special type of class that contains only two possible values: TRUE or FALSE\r\nPlease note that the logical values must be written in all caps with no quotes\r\n\r\n\r\nlog1 <- TRUE\r\nlog2 <- FALSE\r\n\r\n\r\nOnce again, we’ll check the classes of the variables we’ve just created\r\n\r\n\r\nclass(log1)\r\n\r\n[1] \"logical\"\r\n\r\nclass(log2)\r\n\r\n[1] \"logical\"\r\n\r\nWhat happens if we try the following?\r\n\r\n\r\nlog3 <- \"TRUE\"\r\nclass(log3)\r\n\r\n[1] \"character\"\r\n\r\nBecause TRUE is in “” here, by default R assigns this to the character class\r\n\r\n\r\nlog4 <- true\r\n\r\n\r\nThis example doesn’t even run! R gives us an error here saying “object ‘true’ not found”\r\nSummary\r\nCharacter: list of character strings\r\nNumeric: whole numbers OR numbers with decimals\r\nInteger: Only whole numbers\r\nLogical: TRUE or FALSE\r\nTHE END 🎉\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-03-12T14:24:13-05:00",
    "input_file": {}
  },
  {
    "path": "lessons/lesson3-data-structure/",
    "title": "3. Data Structure - Part 1",
    "description": "In this lesson we will review different data structures in R, including vectors, matrices, and arrays.",
    "author": [],
    "date": "2023-02-18",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nVectors\r\nMatrices\r\nArrays\r\nTHE END 🎉\r\n\r\nA data structure is a unique way of organizing data so that it can be stored, processed, and retrieved effectively. In this lesson we will review some of the different data structures in R, including the following:\r\nVectors\r\nMatrices\r\nArrays\r\nIn the Data Structure - Part 2 lesson, we will review:\r\nData frames\r\nTibbles\r\nDepending on what you are using R for, you will probably use a specific type of data structure most frequently. For example, in my research, I use data frames and tibbles all the time and rarely use matrices or arrays. However, it is still useful to be aware of and understand the different types of data structures.\r\nVectors\r\nIn R, a vector is the simplest type of data structure. It is a sequence of data elements of the same basic type.\r\nIn the example below, we have three people (who happen to be myself and my two brothers) - Josh, Jenny, and Brandon. Here, we are creating three separate vectors:\r\nnames that contains character strings of our three names.\r\nage that contains numeric values representing our respective ages (at least at the time of writing this, but I will happily remain 30 forever).\r\nblue_eyes that contains logical values representing whether we have blue eyes or not.\r\n\r\n\r\nnames <- c(\"Josh\", \"Jenny\", \"Brandon\")\r\nnames\r\n\r\n[1] \"Josh\"    \"Jenny\"   \"Brandon\"\r\n\r\nage <- c(31, 30, 27)\r\nage\r\n\r\n[1] 31 30 27\r\n\r\nblue_eyes <- c(TRUE, FALSE, FALSE)\r\nblue_eyes\r\n\r\n[1]  TRUE FALSE FALSE\r\n\r\nOnce you run the above R chunk, you can click on the Environment tab and see how the data is stored. It even shows the data types (num, logi, chr).\r\nIn this example, it’s important to notice that each vector only contains one type of data. We can also see the type of data stored with the class() function.\r\nThe lines of code below are not being assigned (or saved) to any variables, so the results will be returned in the console, but not saved to the Environment.\r\n\r\n\r\nclass(names)\r\n\r\n[1] \"character\"\r\n\r\nclass(age)\r\n\r\n[1] \"numeric\"\r\n\r\nclass(blue_eyes)\r\n\r\n[1] \"logical\"\r\n\r\nMatrices\r\nA matrix has 2 dimensions of data and contains only one type of data. Matrices look like a typical table. In my experience, matrices typically contain numeric values, but there can also be character matrices.\r\nR has a built-in matrix() function.\r\nIn the example below, we will create a matrix of the numbers 1 through 25 and fill it into a 5x5 matrix (5 rows and 5 columns).\r\nWe will save our matrix to a variable called my_matrix.\r\n\r\n\r\nmy_matrix <- matrix(data = 1:25, nrow = 5, ncol = 5)\r\nmy_matrix\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nWe can see that the data perfectly fill in our matrix.\r\nBy default, R has filled in our matrix by columns, so we can see that 1, 2, 3, 4, 5 are filled in the first column and then it moves on to the next column.\r\nIf you want to fill in your matrix by rows (instead of columns), you can set the byrow argument to equal TRUE like in the example below.\r\nPlease note, we will review functions and arguments in more detail in a couple of lessons.\r\n\r\n\r\nmy_matrix_byrow <- matrix(data = 1:25, nrow = 5, ncol = 5, byrow = TRUE)\r\n\r\nmy_matrix_byrow\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    2    3    4    5\r\n[2,]    6    7    8    9   10\r\n[3,]   11   12   13   14   15\r\n[4,]   16   17   18   19   20\r\n[5,]   21   22   23   24   25\r\n\r\nHere’s an example of a matrix with character strings, specifically the colors of the rainbow.\r\nNote, that the character strings are in quotes and wrapped around a c() function, which simply combines the elements.\r\n\r\n\r\nrainbow_matrix <- matrix(data = c(\"red\", \"orange\", \"yellow\", \r\n                                  \"green\", \"blue\", \"purple\"), nrow = 2, ncol = 3)\r\nrainbow_matrix\r\n\r\n     [,1]     [,2]     [,3]    \r\n[1,] \"red\"    \"yellow\" \"blue\"  \r\n[2,] \"orange\" \"green\"  \"purple\"\r\n\r\nYou can access an item within your matrix by using [] where the first number represents which column and the second represents which row.\r\n\r\n\r\nmy_matrix[2,4]\r\n\r\n[1] 17\r\n\r\nmy_matrix_byrow[2,4]\r\n\r\n[1] 9\r\n\r\nrainbow_matrix[1,3]\r\n\r\n[1] \"blue\"\r\n\r\nNext, we’ll test out what happens if we try to create a matrix that is smaller than our data:\r\n\r\n\r\nmatrix(data = 1:25, nrow = 4, ncol = 4)\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    5    9   13\r\n[2,]    2    6   10   14\r\n[3,]    3    7   11   15\r\n[4,]    4    8   12   16\r\n\r\nHere, we can see that R did print our 4x4 matrix, but we are also given a useful warning notifying us that the length of our data (25) does not fit\r\nNext, let’s test out what happens if we try to create a matrix that is larger than our given data:\r\n\r\n\r\nmatrix(data = 1:25, nrow = 6, ncol = 6)\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6]\r\n[1,]    1    7   13   19   25    6\r\n[2,]    2    8   14   20    1    7\r\n[3,]    3    9   15   21    2    8\r\n[4,]    4   10   16   22    3    9\r\n[5,]    5   11   17   23    4   10\r\n[6,]    6   12   18   24    5   11\r\n\r\nAgain, we see that R does return our matrix, but notice what happens after it reaches our max value of 25… it starts over! R will recycle the values, so after 25, it will go back to 1.\r\nNote that we also get the same warning as we saw previously because our data does not fit perfectly.\r\nMatrices are often used for data transformation. So as a final example of matrices, let’s see how we can easily transform our my_matrix matrix to a new matrix that is multiplied by 2.\r\nThis is as simple as multiplying our original matrix by 2!\r\n\r\n\r\n# original matrix\r\nmy_matrix\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\n# matrix multiplied by 2\r\nmy_matrix*2\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    2   12   22   32   42\r\n[2,]    4   14   24   34   44\r\n[3,]    6   16   26   36   46\r\n[4,]    8   18   28   38   48\r\n[5,]   10   20   30   40   50\r\n\r\nArrays\r\nAn array has 1 or more dimensions of data, but only contains a single data type.\r\nR has a built-in array() function.\r\nBelow, we will create a simple vector of a sequence 1 through 18 and.\r\nThen we will call the array function to see what happens.\r\nEven though we are calling an array() we can see that this type of an array is simply a vector.\r\nNow we know that a 1-dimensional array is a vector.\r\n\r\n\r\nvector <- 1:25\r\n\r\narray(vector)\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22\r\n[23] 23 24 25\r\n\r\nLet’s delve a bit further!\r\nThe array() function has an argument called “dim”, which is where we can set the dimensions.\r\nHere are a few examples of multi-dimensional arrays:\r\n\r\n\r\narray(vector, dim = c(5,5))\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nThis should look very familiar!\r\nThis example is meant to demonstrate that 2 dimensional arrays are matrices.\r\nHowever, arrays can also contain more than 2 dimensions…let’s see what happens if we add another dimension.\r\n\r\n\r\narray(vector, dim = c(5,5,2))\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    6   11   16   21\r\n[2,]    2    7   12   17   22\r\n[3,]    3    8   13   18   23\r\n[4,]    4    9   14   19   24\r\n[5,]    5   10   15   20   25\r\n\r\nThe first number in our dim argument tells us how many rows will be in our array\r\nThe second number specifies the number of columns\r\nThe third number specifies the number of dimensions\r\nHere’s one final example, but I encourage you to play around with the array() and test out different numbers and dimensions\r\n\r\n\r\narray(vector, dim = c(2,3,4))\r\n\r\n, , 1\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n, , 2\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    7    9   11\r\n[2,]    8   10   12\r\n\r\n, , 3\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   13   15   17\r\n[2,]   14   16   18\r\n\r\n, , 4\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   19   21   23\r\n[2,]   20   22   24\r\n\r\nFor more examples check out this website.\r\nTHE END 🎉\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-03-12T16:32:57-05:00",
    "input_file": "lesson3-data-structure.knit.md"
  },
  {
    "path": "lessons/lesson4-packages-functions/",
    "title": "4. Packages and Functions",
    "description": "In this lesson we will review the basics of packages (including Tidyverse) and functions.",
    "author": [],
    "date": "2023-02-17",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nPackages\r\nPalmerpenguins\r\nTidyverse\r\nErrors installing new package…what do you do when you encounter errors?\r\n\r\nFunctions\r\nArguments\r\nHelp Documentation\r\nmean() Help Documentation\r\nWhy Use Functions?\r\n\r\nTHE END 🎉\r\n\r\nPackages\r\nA package is a collections of code, data, and documentation all bundled together in a standardized way that can be easily shared and installed by other R users.\r\nInstalling packages: when you want to use a package for the first time, you must install the package with install.packages(\"package_name\") - note the package name must be in quotes. You only need to install a package 1 time on your local computer, so I suggest using the console to install packages.\r\nLoading packages/libraries: every time you start a new session, you have to tell R what packages you want to load in. You do this with the library(package_name) - note the package name does not need to be in quotes here.\r\nPalmerpenguins\r\nTo start, let’s have a look at the palmerpenguins package.\r\nIn the palmerpenguins package, there is a dataset called penguins. Therefore, when you install and load in the package, you will automatically have access to this dataset.\r\nHowever, if we try to run penguins before we install or load in the package, we will get an error message:\r\n\r\n\r\n\r\n\r\n\r\n\r\nBut once we install and load in the palmerpenguins, we can see the penguins dataset!\r\n\r\n\r\n# install.packages(\"palmerpenguins\")\r\n\r\nlibrary(palmerpenguins)\r\npenguins\r\n\r\n# A tibble: 344 × 8\r\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\r\n   <fct>   <fct>              <dbl>         <dbl>             <int>\r\n 1 Adelie  Torgersen           39.1          18.7               181\r\n 2 Adelie  Torgersen           39.5          17.4               186\r\n 3 Adelie  Torgersen           40.3          18                 195\r\n 4 Adelie  Torgersen           NA            NA                  NA\r\n 5 Adelie  Torgersen           36.7          19.3               193\r\n 6 Adelie  Torgersen           39.3          20.6               190\r\n 7 Adelie  Torgersen           38.9          17.8               181\r\n 8 Adelie  Torgersen           39.2          19.6               195\r\n 9 Adelie  Torgersen           34.1          18.1               193\r\n10 Adelie  Torgersen           42            20.2               190\r\n# … with 334 more rows, and 3 more variables: body_mass_g <int>,\r\n#   sex <fct>, year <int>\r\n\r\nTidyverse\r\nTidyverse is a package, well it’s actually a collection of 8 packages (ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats) introduced by Hadley Wickham to help with data manipulation, exploration, and visualization.\r\nYou can check out the tidyverse to find out more details of each of the individual packages.\r\nWhenever you load tidyverse, you’ll see a message saying it’s attaching all 8 packages. Therefore, you don’t have to load in any of the individual packages because they all get loaded in together. This means as long as you load in tidyverse, you can use functions from any one of the 8 packages.\r\n\r\n\r\n# install.packages(\"tidyverse\") # run in console\r\n\r\nlibrary(tidyverse)\r\n\r\n── Attaching packages ───────────────────────────── tidyverse 1.3.1 ──\r\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\r\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\r\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\r\n✔ readr   2.1.2     ✔ forcats 0.5.1\r\n── Conflicts ──────────────────────────────── tidyverse_conflicts() ──\r\n✖ dplyr::filter() masks stats::filter()\r\n✖ dplyr::lag()    masks stats::lag()\r\n\r\nErrors installing new package…what do you do when you encounter errors?\r\nIf you are an active R user, I can almost guarantee that sooner or later you will run into error messages when trying to install an R package. So what do you do when this happens? To see, let’s go through an example.\r\nLet’s say we discovered there’s an emo package that let’s us insert emojis and we want to install the package.\r\nLike any other package, the first thing we do is try to install the package in the console with the following code:\r\n\r\n\r\n\r\n\r\n\r\n\r\nUnfortunately, we get a warning message package 'emo' is not available for this version of R. At first, this may be a little misleading because you may think the issue is that you do not have the right version of R.\r\nBut, really the problem is this package does not exist on Comprehensive R Archive Network (CRAN) and the install.packages() function only works for packages that are part of CRAN.\r\nOne way to check if the package is part of CRAN is to navigate to the Packages tab (by default, this should be located in the bottom right panel of RStudio) and type in the package you’re interested in installing.\r\nWe can see that emo is not there.\r\nSo, if the package is not part of CRAN, what should you do?\r\nTurn to Google! I typically go to Google and search “install package X in R”.\r\nFind the package repository on GitHub. If packages aren’t on CRAN, you should be able to find the package repository on GitHub and then you can install the package via devtools (another package).\r\nWhen I search for the emo package on Google, this is the first link: Emo GitHub Repository.\r\nOn the GitHub Repository, scroll down and look for instructions on how to install the package.\r\nThe code below is taken directly from the website (note, you do have to install the devtools package if you haven’t already done so).\r\nAll you have to do is run this code in your console and you’ll be able to install the emo package!\r\n\r\n\r\n# install.packages(\"devtools\")\r\ndevtools::install_github(\"hadley/emo\")\r\n\r\n\r\nAs a small aside, note that we don’t have to call the library for devtools in the code above because we are explicitly telling R that the install_github function is from (::) the devtools package.\r\nThe code above is identical to running the code in two lines like this:\r\n\r\n\r\n# install.packages(\"devtools\")\r\nlibrary(devtools)\r\ninstall_github(\"hadley/emo\")\r\n\r\n\r\nLet’s test it out our new emo package!\r\nRemember, it’s not enough to install the package. We also have to load the library.\r\n\r\n\r\nlibrary(emo)\r\nji(\"smile\")\r\n\r\n😄 \r\n\r\nFinally, I want to share this installing packages blog that I found super helpful, especially this screenshot of a flow chart on “Approaching Package Issues Systematically”:\r\n\r\n\r\n\r\nFunctions\r\nA function is a set of statements (or code) organized to perform a specific task. Essentially, a function is like a black box where you enter inputs and you get an output. R has a lot of built-in functions.\r\nFor example, there’s a mean() function that calculates the average of the data you include in the function.\r\nHere we can easily calculate the mean of my_values:\r\n\r\n\r\nmy_values = c(10,20,30)\r\n\r\nmean(my_values)\r\n\r\n[1] 20\r\n\r\nArguments\r\nAn argument is the information passed into any given function. In the example above we passed in one argument consisting of “my_values”. The output returned the average of 10, 20, and 30.\r\nAs another example of this function, let’s say we wanted to get the average bill length of the penguins in the palmerpenguins dataset.\r\nHere, we have to specify the dataset and the column of data we want to use in our mean calculation. We can do this by using the $ operator.\r\nHowever, if we run the code below, we get a strange result:\r\n\r\n\r\nmean(penguins$bill_length_mm)\r\n\r\n[1] NA\r\n\r\nWhy did we get NA? We cannot calculate a mean score if there are NA values, so we need to remove these values.\r\nFortunately, there is an argument that let’s us do just that: “na.rm = TRUE” (remove NA = TRUE).\r\n\r\n\r\nmean(penguins$bill_length_mm, na.rm = TRUE)\r\n\r\n[1] 43.92193\r\n\r\nWe can turn to the help documentation to see the different arguments of a function.\r\nHelp Documentation\r\nIf you are using a function for the first time, you may not know where to start.\r\nOne useful tool is R’s help documentation (the help tab in the bottom right panel).\r\nYou can simply search for the function name to learn more about the function. For example, the documentation provides a description, usage, arguments, and often even examples.\r\nAs a shortcut you can also type a ? followed by the function name in the console. For example, ?mean which will take you directly to the help documentation for the mean function.\r\n\r\nmean() Help Documentation\r\n\r\n\r\n\r\nFirst, we immediately see the description: “Generic function for the (trimmed) arithmetic mean”.\r\nThen, we can see that the usage says: “mean(x, …)”\r\nThis means that we need to provide an argument for x. If we scroll down a bit further we can see that x is defined. Basically, this is saying that in order to calculate a mean score, you need to put in some data (aka x)\r\nThe ... tells us that there are other arguments, but they are not required. For example, the “na.rm” is one argument, but it is not required.\r\n\r\nNext, we see a list of the different possible arguments.\r\nAnd if you scroll all the way down to the bottom, you will see examples of how to use the function.\r\nWhy Use Functions?\r\nFunctions save us a lot of time! We often rely on functions that other people have written. So, while we could have taken the time to write our own mean function, there’s no need to because the function already exists. It should hopefully be clear from the last example how powerful the mean function can be and how much time it can save us.\r\nYou can create your own functions specific to your code and your tasks. As a general rule, if you find yourself writing the same code more than twice, you should consider writing a function. Using functions can reduce your chances of making errors. For example, if you need to update your code and you have a function, you only need to update it in one place. However, if you have the same code written 5 times, there’s a pretty high chance that you’ll forget to update your code somewhere, which will result in an error.\r\nAlthough writing your own function is beyond the scope of this lesson, here are some useful websites if you wish to learn more:\r\nR for Data Science: Functions\r\nHow to create your own functions in R\r\nTHE END 🎉\r\n\r\n\r\n\r\n",
    "preview": "lessons/lesson4-packages-functions/images/penguin-error.png",
    "last_modified": "2023-03-12T16:33:28-05:00",
    "input_file": "lesson4-packages-functions.knit.md",
    "preview_width": 564,
    "preview_height": 74
  },
  {
    "path": "lessons/lesson5-data-structure2/",
    "title": "5. Data Structure - Part 2",
    "description": "In this lesson we will review different data structures in R, including data frames and tibbles.",
    "author": [],
    "date": "2023-02-16",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nData frames\r\nmtcars example\r\nHelpful Functions to Explore Data Frame\r\n\r\nTibbles\r\nPenguins example\r\nSo what is special about tibbles?\r\nConverting a data frame to a tibble\r\nCreate our own tibble\r\n\r\nTHE END 🎉\r\n\r\nIn the previous Data Structure lesson we reviewed vectors, matrices, and arrays. And now in this lesson we will review:\r\nData frames\r\nTibbles\r\nData frames\r\nA data frame is a common way of storing data in R.\r\nIn data frames, the columns are the different variables of the data set and the rows are unique observations.\r\nThis may sound similar to matrices, but matrices can only have one type of data.\r\nData frames can have variables of different types. For example, one variable may be a character and one may be numeric.\r\nR has several built-in data sets formatted into data frames (e.g., mtcars, iris, toothgrowth, and more).\r\nmtcars example\r\nLet’s take a look at mtcars:\r\n\r\n\r\nmtcars\r\n\r\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear\r\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4\r\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4\r\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4\r\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3\r\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3\r\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3\r\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3\r\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4\r\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4\r\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4\r\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4\r\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3\r\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3\r\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3\r\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3\r\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3\r\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3\r\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4\r\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4\r\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4\r\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3\r\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3\r\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3\r\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3\r\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3\r\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4\r\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5\r\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5\r\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5\r\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5\r\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5\r\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4\r\n                    carb\r\nMazda RX4              4\r\nMazda RX4 Wag          4\r\nDatsun 710             1\r\nHornet 4 Drive         1\r\nHornet Sportabout      2\r\nValiant                1\r\nDuster 360             4\r\nMerc 240D              2\r\nMerc 230               2\r\nMerc 280               4\r\nMerc 280C              4\r\nMerc 450SE             3\r\nMerc 450SL             3\r\nMerc 450SLC            3\r\nCadillac Fleetwood     4\r\nLincoln Continental    4\r\nChrysler Imperial      4\r\nFiat 128               1\r\nHonda Civic            2\r\nToyota Corolla         1\r\nToyota Corona          1\r\nDodge Challenger       2\r\nAMC Javelin            2\r\nCamaro Z28             4\r\nPontiac Firebird       2\r\nFiat X1-9              1\r\nPorsche 914-2          2\r\nLotus Europa           2\r\nFord Pantera L         4\r\nFerrari Dino           6\r\nMaserati Bora          8\r\nVolvo 142E             2\r\n\r\nR returns the entire data frame, so if you’re like me and like to view your output in the console of RStudio, you’ll probably need to scroll up in order to see first row along with the variables.\r\nWe can see there are 11 variables, but it’s hard to know exactly how many rows (or observations) there are.\r\nWe can type ?mtcars into the console to get more information.\r\n\r\nHere, we can see there are 32 observations and we can see what each variable is.\r\nHelpful Functions to Explore Data Frame\r\nWe can also use existing functions to help us understand our data better:\r\nhead() returns the top 6 rows. This doesn’t actually give us any new information about our data set, but it’s a really useful function to know about because it’s helpful to be able to get a view of the first several rows along with the variable names.\r\n\r\n\r\nhead(mtcars)\r\n\r\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\r\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\r\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\r\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\r\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\r\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\r\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\r\n\r\nView() allows you to view the data frame in a new window, making it easier to explore the full data set.\r\n\r\n\r\nView(mtcars)\r\n\r\n\r\n\r\n\r\n\r\nnrow() returns the total number of rows in your data frame.\r\n\r\n\r\nnrow(mtcars)\r\n\r\n[1] 32\r\n\r\nncol() returns the total number of columns in your data frame.\r\n\r\n\r\nncol(mtcars)\r\n\r\n[1] 11\r\n\r\nstr() returns the “structure” of our data frame in a compact way.\r\nWe can see the number of observations and number of variables.\r\nWe can also see a bit more information about each variable. For example, we can see that all of the variables in mtcars are numeric. It even lists the first several observations for each variable.\r\nglimpse() is a similar function to str(). I encourage you to try it out!\r\n\r\n\r\nstr(mtcars)\r\n\r\n'data.frame':   32 obs. of  11 variables:\r\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\r\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\r\n $ disp: num  160 160 108 258 360 ...\r\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\r\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\r\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\r\n $ qsec: num  16.5 17 18.6 19.4 17 ...\r\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\r\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\r\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\r\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\r\n\r\n\r\n\r\n\r\nsummary() provides a summary of the different variables. Because all the variables are numeric, we can see the summary function returns the following information: minimum value, 1st quartile (25th percentile), median, mean, 3rd quartile (75th percentile), and maximum value.\r\n\r\n\r\nsummary(mtcars)\r\n\r\n      mpg             cyl             disp             hp       \r\n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \r\n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \r\n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \r\n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \r\n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \r\n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \r\n      drat             wt             qsec             vs        \r\n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \r\n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \r\n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \r\n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \r\n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \r\n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \r\n       am              gear            carb      \r\n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \r\n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \r\n Median :0.0000   Median :4.000   Median :2.000  \r\n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \r\n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \r\n Max.   :1.0000   Max.   :5.000   Max.   :8.000  \r\n\r\nWhat if we only wanted to get a summary of the first variable, mpg? No problem, we can modify the code like this:\r\n\r\n\r\nsummary(mtcars$mpg)\r\n\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n  10.40   15.43   19.20   20.09   22.80   33.90 \r\n\r\nTibbles\r\nA tibble is a type of data frame with some special features that we will explore. If you use tidyverse, chances our you’ll see a lot of tibbles!\r\nThere are some differences between tibbles and data frames, but those are not important when learning the basics. We’ll go through the basic differences, but here’s a useful link if you’re interested in learning more about tibbles: tibble.tidyverse.org.\r\nPenguins example\r\nTo understand the unique features of a tibble, we’ll explore the penguins data set that is included in the palmerpenguins package.\r\nIn the last lesson, we learned about packages. We know the first things we need to do is load the package and then we will have access to the penguins data set.\r\n\r\n\r\nlibrary(palmerpenguins)\r\npenguins\r\n\r\n# A tibble: 344 × 8\r\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\r\n   <fct>   <fct>              <dbl>         <dbl>             <int>\r\n 1 Adelie  Torgersen           39.1          18.7               181\r\n 2 Adelie  Torgersen           39.5          17.4               186\r\n 3 Adelie  Torgersen           40.3          18                 195\r\n 4 Adelie  Torgersen           NA            NA                  NA\r\n 5 Adelie  Torgersen           36.7          19.3               193\r\n 6 Adelie  Torgersen           39.3          20.6               190\r\n 7 Adelie  Torgersen           38.9          17.8               181\r\n 8 Adelie  Torgersen           39.2          19.6               195\r\n 9 Adelie  Torgersen           34.1          18.1               193\r\n10 Adelie  Torgersen           42            20.2               190\r\n# … with 334 more rows, and 3 more variables: body_mass_g <int>,\r\n#   sex <fct>, year <int>\r\n\r\nThe first line of output says: “A tibble: 344 x 8”. Straight away, we get confirmation that this data frame is a tibble. And there are 344 rows and 8 columns.\r\nBecause tibbles are a type of data frame, similar to what we saw with the mtcars data frame, each column is a variable and each row is a unique observation.\r\nJust to confirm, we can run the following 2 lines of code to see that penguins is both a data frame and a tibble:\r\nNote: is_tibble() is a function in the tibble package, which is part of tidyverse, so we need to load in the tidyverse library first.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nis.data.frame(penguins)\r\n\r\n[1] TRUE\r\n\r\nis_tibble(penguins)\r\n\r\n[1] TRUE\r\n\r\nSo what is special about tibbles?\r\nTibbles are simple data frames with some features that make working with the data really nice.\r\nAs already pointed out, the tibble shows us exactly how big our data set is (344 rows and 8 columns).\r\nIt automatically only prints out the first 10 rows, so it’s much easier to see the variables in our data set.\r\nUnder each variable name, we see what type of variable it is (e.g., fct, dbl, int, etc.)\r\nAs a small aside, tidyverse uses “dbl” (“double”) instead of “numeric”, but they are identical.\r\n\r\nR only returns the number of columns that fit on your screen. For example, if you view your output in the console, it’s likely that not all of the variables will neatly fit on your screen. Under the 10 rows of data, you may see something like: “and 1 more variable: year ”. This is great because you get important information on all of the variables even if there are too many to fit on your screen.\r\nConverting a data frame to a tibble\r\nRecall, that by default mtcars is a data frame and not a tibble,\r\n\r\n\r\nmtcars\r\n\r\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear\r\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4\r\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4\r\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4\r\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3\r\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3\r\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3\r\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3\r\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4\r\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4\r\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4\r\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4\r\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3\r\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3\r\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3\r\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3\r\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3\r\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3\r\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4\r\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4\r\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4\r\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3\r\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3\r\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3\r\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3\r\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3\r\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4\r\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5\r\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5\r\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5\r\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5\r\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5\r\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4\r\n                    carb\r\nMazda RX4              4\r\nMazda RX4 Wag          4\r\nDatsun 710             1\r\nHornet 4 Drive         1\r\nHornet Sportabout      2\r\nValiant                1\r\nDuster 360             4\r\nMerc 240D              2\r\nMerc 230               2\r\nMerc 280               4\r\nMerc 280C              4\r\nMerc 450SE             3\r\nMerc 450SL             3\r\nMerc 450SLC            3\r\nCadillac Fleetwood     4\r\nLincoln Continental    4\r\nChrysler Imperial      4\r\nFiat 128               1\r\nHonda Civic            2\r\nToyota Corolla         1\r\nToyota Corona          1\r\nDodge Challenger       2\r\nAMC Javelin            2\r\nCamaro Z28             4\r\nPontiac Firebird       2\r\nFiat X1-9              1\r\nPorsche 914-2          2\r\nLotus Europa           2\r\nFord Pantera L         4\r\nFerrari Dino           6\r\nMaserati Bora          8\r\nVolvo 142E             2\r\n\r\nHowever, we can easily use the as_tibble() function to convert it to a tibble.\r\n\r\n\r\nas_tibble(mtcars)\r\n\r\n# A tibble: 32 × 11\r\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\r\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\r\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\r\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\r\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\r\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\r\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\r\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\r\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\r\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\r\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\r\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\r\n# … with 22 more rows\r\n\r\nThis example should highlight the advantages of working with tibbles.\r\nPersonally, I try to work exclusively with tibbles because I find it so much easier and cleaner.\r\nCreate our own tibble\r\nIn the Data Structure: Part 1 lesson, we created three vectors: names, age, and blue_eyes. Now, let’s create a tibble consisting of these three vectors.\r\nWe will use the tibble() function.\r\nEach line of our tibble represents a unique variable (or column). The text to the left of the equals sign is the variable name and the text to right is the data we want to be stored in our tibble. For example, Name is variable name for the first column and the data is our names vector (Josh, Jenny, Brandon).\r\nWe will save our tibble as my_tibble().\r\n\r\n\r\nnames <- c(\"Josh\", \"Jenny\", \"Brandon\")\r\nages <- c(31, 30, 27)\r\nblue_eyes <- c(TRUE, FALSE, FALSE)\r\n\r\nmy_tibble <- tibble(\r\n  Name = names,\r\n  Age = ages,\r\n  Blue_eye = blue_eyes\r\n)\r\n\r\nmy_tibble\r\n\r\n# A tibble: 3 × 3\r\n  Name      Age Blue_eye\r\n  <chr>   <dbl> <lgl>   \r\n1 Josh       31 TRUE    \r\n2 Jenny      30 FALSE   \r\n3 Brandon    27 FALSE   \r\n\r\nAnd just like that, we created our very own 3x3 tibble!\r\nTHE END 🎉\r\n\r\n\r\n\r\n",
    "preview": "lessons/lesson5-data-structure2/images/view-mtcars.png",
    "last_modified": "2023-03-12T16:33:50-05:00",
    "input_file": "lesson5-data-structure2.knit.md",
    "preview_width": 780,
    "preview_height": 485
  }
]
